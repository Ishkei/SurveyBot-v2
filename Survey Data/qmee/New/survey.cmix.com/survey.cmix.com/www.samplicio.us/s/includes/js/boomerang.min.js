function BOOMR_check_doc_domain(domain) {
  if (window) {
    if (!domain) {
      if (window.parent === window || !document.getElementById("boomr-if-as")) {
        return;
      }
      if (window.BOOMR && BOOMR.boomerang_frame && BOOMR.window) {
        try {
          BOOMR.boomerang_frame.document.domain !==
            BOOMR.window.document.domain &&
            (BOOMR.boomerang_frame.document.domain =
              BOOMR.window.document.domain);
        } catch (err) {
          BOOMR.isCrossOriginError(err) ||
            BOOMR.addError(err, "BOOMR_check_doc_domain.domainFix");
        }
      }
      domain = document.domain;
    }
    if (-1 !== domain.indexOf(".")) {
      try {
        window.parent.document;
        return;
      } catch (err) {
        document.domain = domain;
      }
      try {
        window.parent.document;
        return;
      } catch (err) {
        domain = domain.replace(/^[\w\-]+\./, "");
      }
      BOOMR_check_doc_domain(domain);
    }
  }
}
BOOMR_start = new Date().getTime();
BOOMR_check_doc_domain();
(function (w) {
  var impl,
    boomr,
    d,
    myurl,
    createCustomEvent,
    dispatchEvent,
    visibilityState,
    visibilityChange,
    orig_w = w;
  if (
    w.parent !== w &&
    document.getElementById("boomr-if-as") &&
    "script" === document.getElementById("boomr-if-as").nodeName.toLowerCase()
  ) {
    w = w.parent;
    myurl = document.getElementById("boomr-if-as").src;
  }
  d = w.document;
  w.BOOMR || (w.BOOMR = {});
  BOOMR = w.BOOMR;
  if (!BOOMR.version) {
    BOOMR.version = "1.0.1-1723824142";
    BOOMR.window = w;
    BOOMR.boomerang_frame = orig_w;
    BOOMR.plugins || (BOOMR.plugins = {});
    (function () {
      try {
        void 0 !== new w.CustomEvent("CustomEvent") &&
          (createCustomEvent = function (e_name, params) {
            return new w.CustomEvent(e_name, params);
          });
      } catch (ignore) {}
      try {
        !createCustomEvent &&
          d.createEvent &&
          d.createEvent("CustomEvent") &&
          (createCustomEvent = function (e_name, params) {
            var evt = d.createEvent("CustomEvent");
            params = params || { cancelable: !1, bubbles: !1 };
            evt.initCustomEvent(
              e_name,
              params.bubbles,
              params.cancelable,
              params.detail
            );
            return evt;
          });
      } catch (ignore) {}
      !createCustomEvent &&
        d.createEventObject &&
        (createCustomEvent = function (e_name, params) {
          var evt = d.createEventObject();
          evt.type = evt.propertyName = e_name;
          evt.detail = params.detail;
          return evt;
        });
      createCustomEvent || (createCustomEvent = function () {});
    })();
    dispatchEvent = function (e_name, e_data, async) {
      function dispatch() {
        d.dispatchEvent
          ? d.dispatchEvent(ev)
          : d.fireEvent && d.fireEvent("onpropertychange", ev);
      }
      var ev = createCustomEvent(e_name, { detail: e_data });
      ev && (async ? BOOMR.setImmediate(dispatch) : dispatch());
    };
    if (void 0 !== document.hidden) {
      visibilityState = "visibilityState";
      visibilityChange = "visibilitychange";
    } else if (void 0 !== document.mozHidden) {
      visibilityState = "mozVisibilityState";
      visibilityChange = "mozvisibilitychange";
    } else if (void 0 !== document.msHidden) {
      visibilityState = "msVisibilityState";
      visibilityChange = "msvisibilitychange";
    } else if (void 0 !== document.webkitHidden) {
      visibilityState = "webkitVisibilityState";
      visibilityChange = "webkitvisibilitychange";
    }
    impl = {
      beacon_url: "",
      beacon_type: "AUTO",
      beacon_auth_key: "Authorization",
      beacon_auth_token: "",
      site_domain: w.location.hostname
        .replace(/.*?([^.]+\.[^.]+)\.?$/, "$1")
        .toLowerCase(),
      user_ip: "",
      autorun: !0,
      events: {
        page_ready: [],
        page_unload: [],
        before_unload: [],
        dom_loaded: [],
        visibility_changed: [],
        prerender_to_visible: [],
        before_beacon: [],
        onbeacon: [],
        xhr_load: [],
        click: [],
        form_submit: [],
      },
      public_events: {
        before_beacon: "onBeforeBoomerangBeacon",
        onbeacon: "onBoomerangBeacon",
        onboomerangloaded: "onBoomerangLoaded",
      },
      vars: {},
      varPriority: { "-1": {}, 1: {} },
      errors: {},
      disabled_plugins: {},
      xb_handler: function (type) {
        return function (ev) {
          var target;
          ev || (ev = w.event);
          ev.target
            ? (target = ev.target)
            : ev.srcElement && (target = ev.srcElement);
          3 === target.nodeType && (target = target.parentNode);
          (target &&
            "OBJECT" === target.nodeName.toUpperCase() &&
            "application/x-shockwave-flash" === target.type) ||
            impl.fireEvent(type, target);
        };
      },
      fireEvent: function (e_name, data) {
        var i, handler, handlers;
        e_name = e_name.toLowerCase();
        if (this.events.hasOwnProperty(e_name)) {
          this.public_events.hasOwnProperty(e_name) &&
            dispatchEvent(this.public_events[e_name], data);
          handlers = this.events[e_name];
          "before_beacon" !== e_name &&
            "onbeacon" !== e_name &&
            BOOMR.real_sendBeacon();
          for (i = 0; i < handlers.length; i++) {
            try {
              handler = handlers[i];
              handler.fn.call(handler.scope, data, handler.cb_data);
            } catch (err) {
              BOOMR.addError(err, "fireEvent." + e_name + "<" + i + ">");
            }
          }
        }
      },
    };
    boomr = {
      t_start: BOOMR_start,
      url: myurl,
      constants: { BEACON_TYPE_SPAS: ["spa", "spa_hard"], MAX_GET_LENGTH: 2e3 },
      utils: {
        objectToString: function (o, separator, nest_level) {
          var k,
            value = [];
          if (!o || "object" != typeof o) {
            return o;
          }
          void 0 === separator && (separator = "\n\t");
          nest_level || (nest_level = 0);
          if ("[object Array]" === Object.prototype.toString.call(o)) {
            for (k = 0; k < o.length; k++) {
              nest_level > 0 && null !== o[k] && "object" == typeof o[k]
                ? value.push(
                    this.objectToString(
                      o[k],
                      separator + ("\n\t" === separator ? "\t" : ""),
                      nest_level - 1
                    )
                  )
                : "&" === separator
                ? value.push(encodeURIComponent(o[k]))
                : value.push(o[k]);
            }
            separator = ",";
          } else {
            for (k in o) {
              Object.prototype.hasOwnProperty.call(o, k) &&
                (nest_level > 0 && null !== o[k] && "object" == typeof o[k]
                  ? value.push(
                      encodeURIComponent(k) +
                        "=" +
                        this.objectToString(
                          o[k],
                          separator + ("\n\t" === separator ? "\t" : ""),
                          nest_level - 1
                        )
                    )
                  : "&" === separator
                  ? value.push(
                      encodeURIComponent(k) + "=" + encodeURIComponent(o[k])
                    )
                  : value.push(k + "=" + o[k]));
            }
          }
          return value.join(separator);
        },
        getCookie: function (name) {
          if (!name) {
            return null;
          }
          name = " " + name + "=";
          var i, cookies;
          cookies = " " + d.cookie + ";";
          if ((i = cookies.indexOf(name)) >= 0) {
            i += name.length;
            cookies = cookies
              .substring(i, cookies.indexOf(";", i))
              .replace(/^"/, "")
              .replace(/"$/, "");
            return cookies;
          }
        },
        setCookie: function (name, subcookies, max_age) {
          var value, nameval, savedval, c, exp;
          if (!name || !impl.site_domain) {
            BOOMR.debug(
              "No cookie name or site domain: " + name + "/" + impl.site_domain
            );
            return !1;
          }
          value = this.objectToString(subcookies, "&");
          nameval = name + '="' + value + '"';
          c = [nameval, "path=/", "domain=" + impl.site_domain];
          if (max_age) {
            exp = new Date();
            exp.setTime(exp.getTime() + 1e3 * max_age);
            exp = exp.toGMTString();
            c.push("expires=" + exp);
          }
          if (nameval.length < 500) {
            d.cookie = c.join("; ");
            savedval = this.getCookie(name);
            if (value === savedval) {
              return !0;
            }
            BOOMR.warn(
              "Saved cookie value doesn't match what we tried to set:\n" +
                value +
                "\n" +
                savedval
            );
          } else {
            BOOMR.warn("Cookie too long: " + nameval.length + " " + nameval);
          }
          return !1;
        },
        getSubCookies: function (cookie) {
          var cookies_a,
            i,
            l,
            kv,
            gotcookies = !1,
            cookies = {};
          if (!cookie) {
            return null;
          }
          if ("string" != typeof cookie) {
            BOOMR.debug("TypeError: cookie is not a string: " + typeof cookie);
            return null;
          }
          cookies_a = cookie.split("&");
          for (i = 0, l = cookies_a.length; i < l; i++) {
            kv = cookies_a[i].split("=");
            if (kv[0]) {
              kv.push("");
              cookies[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
              gotcookies = !0;
            }
          }
          return gotcookies ? cookies : null;
        },
        removeCookie: function (name) {
          return this.setCookie(name, {}, -86400);
        },
        cleanupURL: function (url, urlLimit) {
          if (
            !url ||
            "[object Array]" === Object.prototype.toString.call(url)
          ) {
            return "";
          }
          impl.strip_query_string &&
            (url = url.replace(/\?.*/, "?qs-redacted"));
          if (void 0 !== urlLimit && url && url.length > urlLimit) {
            var qsStart = url.indexOf("?");
            url =
              -1 !== qsStart && qsStart < urlLimit
                ? url.substr(0, qsStart) + "?..."
                : url.substr(0, urlLimit - 3) + "...";
          }
          return url;
        },
        hashQueryString: function (url, stripHash) {
          if (!url) {
            return url;
          }
          if (!url.match) {
            BOOMR.addError(
              "TypeError: Not a string",
              "hashQueryString",
              typeof url
            );
            return "";
          }
          url.match(/^\/\//) && (url = location.protocol + url);
          if (!url.match(/^(https?|file):/)) {
            BOOMR.error("Passed in URL is invalid: " + url);
            return "";
          }
          stripHash && (url = url.replace(/#.*/, ""));
          return BOOMR.utils.MD5
            ? url.replace(/\?([^#]*)/, function (m0, m1) {
                return "?" + (m1.length > 10 ? BOOMR.utils.MD5(m1) : m1);
              })
            : url;
        },
        pluginConfig: function (o, config, plugin_name, properties) {
          var i,
            props = 0;
          if (!config || !config[plugin_name]) {
            return !1;
          }
          for (i = 0; i < properties.length; i++) {
            if (void 0 !== config[plugin_name][properties[i]]) {
              o[properties[i]] = config[plugin_name][properties[i]];
              props++;
            }
          }
          return props > 0;
        },
        arrayFilter: function (array, predicate) {
          var result = [];
          if ("function" == typeof array.filter) {
            result = array.filter(predicate);
          } else {
            var value,
              index = -1,
              length = array.length;
            while (++index < length) {
              value = array[index];
              predicate(value, index, array) && (result[result.length] = value);
            }
          }
          return result;
        },
        addObserver: function (
          el,
          config,
          timeout,
          callback,
          callback_data,
          callback_ctx
        ) {
          function done(mutations) {
            var run_again = !1;
            if (o.timer) {
              clearTimeout(o.timer);
              o.timer = null;
            }
            if (callback) {
              run_again = callback.call(callback_ctx, mutations, callback_data);
              run_again || (callback = null);
            }
            if (!run_again && o.observer) {
              o.observer.disconnect();
              o.observer = null;
            }
            "number" == typeof run_again &&
              run_again > 0 &&
              (o.timer = setTimeout(done, run_again));
          }
          var o = { observer: null, timer: null };
          if (!window.MutationObserver || !callback || !el) {
            return null;
          }
          o.observer = new MutationObserver(done);
          timeout && (o.timer = setTimeout(done, o.timeout));
          o.observer.observe(el, config);
          return o;
        },
        addListener: function (el, type, fn) {
          el.addEventListener
            ? el.addEventListener(type, fn, !1)
            : el.attachEvent && el.attachEvent("on" + type, fn);
        },
        removeListener: function (el, type, fn) {
          el.removeEventListener
            ? el.removeEventListener(type, fn, !1)
            : el.detachEvent && el.detachEvent("on" + type, fn);
        },
        pushVars: function (form, vars, prefix) {
          var k,
            i,
            input,
            l = 0;
          for (k in vars) {
            if (vars.hasOwnProperty(k)) {
              if (
                "[object Array]" === Object.prototype.toString.call(vars[k])
              ) {
                for (i = 0; i < vars[k].length; ++i) {
                  l += BOOMR.utils.pushVars(
                    form,
                    vars[k][i],
                    k + "[" + i + "]"
                  );
                }
              } else {
                input = document.createElement("input");
                input.type = "hidden";
                input.name = prefix ? prefix + "[" + k + "]" : k;
                input.value =
                  void 0 === vars[k] || null === vars[k] ? "" : vars[k];
                form.appendChild(input);
                l +=
                  encodeURIComponent(input.name).length +
                  encodeURIComponent(input.value).length +
                  2;
              }
            }
          }
          return l;
        },
        inArray: function (val, ary) {
          var i;
          if (void 0 === val || void 0 === ary || !ary.length) {
            return !1;
          }
          for (i = 0; i < ary.length; i++) {
            if (ary[i] === val) {
              return !0;
            }
          }
          return !1;
        },
        getQueryParamValue: function (param, url) {
          var l, params, i, kv;
          if (!param) {
            return null;
          }
          if ("string" == typeof url) {
            l = BOOMR.window.document.createElement("a");
            l.href = url;
          } else {
            l =
              "object" == typeof url && "string" == typeof url.search
                ? url
                : BOOMR.window.location;
          }
          params = l.search.slice(1).split(/&/);
          for (i = 0; i < params.length; i++) {
            if (params[i]) {
              kv = params[i].split("=");
              if (kv.length && kv[0] === param) {
                return decodeURIComponent(kv[1].replace(/\+/g, " "));
              }
            }
          }
          return null;
        },
      },
      init: function (config) {
        var i,
          k,
          properties = [
            "beacon_url",
            "beacon_type",
            "beacon_auth_key",
            "beacon_auth_token",
            "site_domain",
            "user_ip",
            "strip_query_string",
            "secondary_beacons",
            "autorun",
          ];
        BOOMR_check_doc_domain();
        config || (config = {});
        if (config.primary && impl.handlers_attached) {
          return this;
        }
        void 0 !== config.log && (this.log = config.log);
        this.log || (this.log = function () {});
        void 0 !== config.autorun && (impl.autorun = config.autorun);
        for (k in this.plugins) {
          if (this.plugins.hasOwnProperty(k)) {
            if (
              config[k] &&
              config[k].hasOwnProperty("enabled") &&
              !1 === config[k].enabled
            ) {
              impl.disabled_plugins[k] = 1;
              "function" == typeof this.plugins[k].disable &&
                this.plugins[k].disable();
              continue;
            }
            if (impl.disabled_plugins[k]) {
              if (
                !config[k] ||
                !config[k].hasOwnProperty("enabled") ||
                !0 !== config[k].enabled
              ) {
                continue;
              }
              "function" == typeof this.plugins[k].enable &&
                this.plugins[k].enable();
              delete impl.disabled_plugins[k];
            }
            if ("function" == typeof this.plugins[k].init) {
              try {
                this.plugins[k].init(config);
              } catch (err) {
                BOOMR.addError(err, k + ".init");
              }
            }
          }
        }
        for (i = 0; i < properties.length; i++) {
          void 0 !== config[properties[i]] &&
            (impl[properties[i]] = config[properties[i]]);
        }
        if (impl.handlers_attached) {
          return this;
        }
        if (
          !impl.onloadfired &&
          (void 0 === config.autorun || !1 !== config.autorun)
        ) {
          if (d.readyState && "complete" === d.readyState) {
            BOOMR.loadedLate = !0;
            this.setImmediate(BOOMR.page_ready_autorun, null, null, BOOMR);
          } else {
            w.onpagehide || null === w.onpagehide
              ? BOOMR.utils.addListener(w, "pageshow", BOOMR.page_ready_autorun)
              : BOOMR.utils.addListener(w, "load", BOOMR.page_ready_autorun);
          }
        }
        BOOMR.utils.addListener(w, "DOMContentLoaded", function () {
          impl.fireEvent("dom_loaded");
        });
        (function () {
          var forms, iterator;
          if (void 0 !== visibilityChange) {
            BOOMR.utils.addListener(d, visibilityChange, function () {
              impl.fireEvent("visibility_changed");
            });
            impl.lastVisibilityState = BOOMR.visibilityState();
            BOOMR.subscribe("visibility_changed", function () {
              var visState = BOOMR.visibilityState();
              BOOMR.lastVisibilityEvent[visState] = BOOMR.now();
              if (
                "prerender" === impl.lastVisibilityState &&
                "prerender" !== visState
              ) {
                BOOMR.addVar("vis.pre", "1");
                impl.fireEvent("prerender_to_visible");
              }
              impl.lastVisibilityState = visState;
            });
          }
          BOOMR.utils.addListener(d, "mouseup", impl.xb_handler("click"));
          forms = d.getElementsByTagName("form");
          for (iterator = 0; iterator < forms.length; iterator++) {
            BOOMR.utils.addListener(
              forms[iterator],
              "submit",
              impl.xb_handler("form_submit")
            );
          }
          w.onpagehide ||
            null === w.onpagehide ||
            BOOMR.utils.addListener(w, "unload", function () {
              BOOMR.window = w = null;
            });
        })();
        impl.handlers_attached = !0;
        return this;
      },
      page_ready_autorun: function (ev) {
        impl.autorun && BOOMR.page_ready(ev);
      },
      page_ready: function (ev) {
        ev || (ev = w.event);
        ev || (ev = { name: "load" });
        if (impl.onloadfired) {
          return this;
        }
        impl.fireEvent("page_ready", ev);
        impl.onloadfired = !0;
        return this;
      },
      setImmediate: function (fn, data, cb_data, cb_scope) {
        var cb, cstack;
        if ("undefined" != typeof Error) {
          cstack = new Error();
          cstack = cstack.stack
            ? cstack.stack.replace(/^Error/, "Called")
            : void 0;
        }
        cb = function () {
          fn.call(cb_scope || null, data, cb_data || {}, cstack);
          cb = null;
        };
        w.setImmediate
          ? w.setImmediate(cb)
          : w.msSetImmediate
          ? w.msSetImmediate(cb)
          : w.webkitSetImmediate
          ? w.webkitSetImmediate(cb)
          : w.mozSetImmediate
          ? w.mozSetImmediate(cb)
          : setTimeout(cb, 10);
      },
      now: (function () {
        try {
          var p = BOOMR.getPerformance();
          if (p && "function" == typeof p.now) {
            return function () {
              return Math.round(p.now() + p.timing.navigationStart);
            };
          }
        } catch (ignore) {}
        return (
          Date.now ||
          function () {
            return new Date().getTime();
          }
        );
      })(),
      getPerformance: function () {
        try {
          if (BOOMR.window) {
            return "performance" in BOOMR.window && BOOMR.window.performance
              ? BOOMR.window.performance
              : BOOMR.window.msPerformance ||
                  BOOMR.window.webkitPerformance ||
                  BOOMR.window.mozPerformance;
          }
        } catch (ignore) {}
      },
      visibilityState:
        void 0 === visibilityState
          ? function () {
              return "visible";
            }
          : function () {
              return d[visibilityState];
            },
      lastVisibilityEvent: {},
      registerEvent: function (e_name) {
        if (impl.events.hasOwnProperty(e_name)) {
          return this;
        }
        impl.events[e_name] = [];
        return this;
      },
      fireEvent: function (e_name, data) {
        return impl.fireEvent(e_name, data);
      },
      subscribe: function (e_name, fn, cb_data, cb_scope) {
        var i, handler, ev;
        e_name = e_name.toLowerCase();
        impl.events.hasOwnProperty(e_name) || (impl.events[e_name] = []);
        ev = impl.events[e_name];
        for (i = 0; i < ev.length; i++) {
          handler = ev[i];
          if (
            handler &&
            handler.fn === fn &&
            handler.cb_data === cb_data &&
            handler.scope === cb_scope
          ) {
            return this;
          }
        }
        ev.push({ fn: fn, cb_data: cb_data || {}, scope: cb_scope || null });
        "page_ready" === e_name &&
          impl.onloadfired &&
          impl.autorun &&
          this.setImmediate(fn, null, cb_data, cb_scope);
        ("page_unload" !== e_name && "before_unload" !== e_name) ||
          (function () {
            var unload_handler,
              evt_idx = ev.length;
            unload_handler = function (evt) {
              fn && fn.call(cb_scope, evt || w.event, cb_data);
              "page_unload" === e_name &&
                evt_idx === impl.events[e_name].length &&
                BOOMR.real_sendBeacon();
            };
            "page_unload" === e_name &&
              (w.onpagehide || null === w.onpagehide
                ? BOOMR.utils.addListener(w, "pagehide", unload_handler)
                : BOOMR.utils.addListener(w, "unload", unload_handler));
            BOOMR.utils.addListener(w, "beforeunload", unload_handler);
          })();
        return this;
      },
      addError: function BOOMR_addError(err, src, extra) {
        var str,
          E = BOOMR.plugins.Errors;
        if (E && E.is_supported()) {
          if ("string" == typeof err) {
            E.send(
              { message: err, extra: extra, functionName: src, noStack: !0 },
              E.VIA_APP,
              E.SOURCE_BOOMERANG
            );
          } else {
            "string" == typeof src && (err.functionName = src);
            void 0 !== extra && (err.extra = extra);
            E.send(err, E.VIA_APP, E.SOURCE_BOOMERANG);
          }
        } else {
          if ("string" != typeof err) {
            str = String(err);
            str.match(/^\[object/) &&
              (str =
                err.name +
                ": " +
                (err.description || err.message).replace(/\r\n$/, ""));
            err = str;
          }
          void 0 !== src && (err = "[" + src + ":" + BOOMR.now() + "] " + err);
          extra && (err += ":: " + extra);
          impl.errors[err] ? impl.errors[err]++ : (impl.errors[err] = 1);
        }
      },
      isCrossOriginError: function (err) {
        return (
          "SecurityError" === err.name ||
          ("TypeError" === err.name && "Permission denied" === err.message) ||
          ("Error" === err.name &&
            err.message &&
            err.message.match(/^(Permission|Access is) denied/))
        );
      },
      addVar: function (name, value) {
        if ("string" == typeof name) {
          impl.vars[name] = value;
        } else if ("object" == typeof name) {
          var k,
            o = name;
          for (k in o) {
            o.hasOwnProperty(k) && (impl.vars[k] = o[k]);
          }
        }
        return this;
      },
      removeVar: function (arg0) {
        var i, params;
        if (!arguments.length) {
          return this;
        }
        params =
          1 === arguments.length &&
          "[object Array]" === Object.prototype.toString.apply(arg0)
            ? arg0
            : arguments;
        for (i = 0; i < params.length; i++) {
          impl.vars.hasOwnProperty(params[i]) && delete impl.vars[params[i]];
        }
        return this;
      },
      hasVar: function (name) {
        return impl.vars.hasOwnProperty(name);
      },
      setVarPriority: function (name, pri) {
        if ("number" != typeof pri || 1 !== Math.abs(pri)) {
          return this;
        }
        impl.varPriority[pri][name] = 1;
        return this;
      },
      requestStart: function (name) {
        var t_start = BOOMR.now();
        BOOMR.plugins.RT.startTimer("xhr_" + name, t_start);
        return {
          loaded: function (data) {
            BOOMR.responseEnd(name, t_start, data);
          },
        };
      },
      readyToSend: function () {
        var plugin;
        for (plugin in this.plugins) {
          if (this.plugins.hasOwnProperty(plugin)) {
            if (impl.disabled_plugins[plugin]) {
              continue;
            }
            if (
              "function" == typeof this.plugins[plugin].readyToSend &&
              !1 === this.plugins[plugin].readyToSend()
            ) {
              BOOMR.debug("Plugin " + plugin + " is not ready to send");
              return !1;
            }
          }
        }
        return !0;
      },
      responseEnd: function (name, t_start, data) {
        if (BOOMR.readyToSend()) {
          if ("object" == typeof name && name.url) {
            impl.fireEvent("xhr_load", name);
          } else {
            BOOMR.real_sendBeacon();
            BOOMR.addVar("xhr.pg", name);
            BOOMR.plugins.RT.startTimer("xhr_" + name, t_start);
            impl.fireEvent("xhr_load", { name: "xhr_" + name, data: data });
          }
        } else if ("object" != typeof name) {
          var timer = name + "|" + (BOOMR.now() - t_start);
          impl.vars.qt ? (impl.vars.qt += "," + timer) : (impl.vars.qt = timer);
        } else {
          BOOMR.debug("Attempt to send a resource before a security token");
        }
      },
      uninstrumentXHR: function () {},
      instrumentXHR: function () {},
      sendBeacon: function (beacon_url_override) {
        beacon_url_override && (impl.beacon_url_override = beacon_url_override);
        if (!impl.beaconQueued) {
          impl.beaconQueued = !0;
          BOOMR.setImmediate(BOOMR.real_sendBeacon, null, null, BOOMR);
        }
        return !0;
      },
      real_sendBeacon: function () {
        var k,
          url,
          img,
          paramsJoined,
          xhr,
          errors = [],
          params = [],
          useImg = 1,
          varsSent = {},
          varsToSend = {},
          urlFirst = [],
          urlLast = [];
        if (!impl.beaconQueued) {
          return !1;
        }
        impl.beaconQueued = !1;
        BOOMR.debug("Checking if we can send beacon");
        for (k in this.plugins) {
          if (this.plugins.hasOwnProperty(k)) {
            if (impl.disabled_plugins[k]) {
              continue;
            }
            if (!this.plugins[k].is_complete()) {
              BOOMR.debug(
                "Plugin " + k + " is not complete, deferring beacon send"
              );
              return !1;
            }
          }
        }
        var isSPA = BOOMR.utils.inArray(
          impl.vars["http.initiator"],
          BOOMR.constants.BEACON_TYPE_SPAS
        );
        var pgu = isSPA ? d.URL : d.URL.replace(/#.*/, "");
        impl.vars.pgu = BOOMR.utils.cleanupURL(pgu);
        (impl.vars.u && !isSPA) || (impl.vars.u = impl.vars.pgu);
        impl.vars.pgu === impl.vars.u && delete impl.vars.pgu;
        impl.vars.v = BOOMR.version;
        if (BOOMR.visibilityState()) {
          impl.vars["vis.st"] = BOOMR.visibilityState();
          BOOMR.lastVisibilityEvent.visible &&
            (impl.vars["vis.lv"] =
              BOOMR.now() - BOOMR.lastVisibilityEvent.visible);
          BOOMR.lastVisibilityEvent.hidden &&
            (impl.vars["vis.lh"] =
              BOOMR.now() - BOOMR.lastVisibilityEvent.hidden);
        }
        impl.vars["ua.plt"] = navigator.platform;
        impl.vars["ua.vnd"] = navigator.vendor;
        w !== window && (impl.vars.if = "");
        for (k in impl.errors) {
          impl.errors.hasOwnProperty(k) &&
            errors.push(
              k + (impl.errors[k] > 1 ? " (*" + impl.errors[k] + ")" : "")
            );
        }
        errors.length > 0 && (impl.vars.errors = errors.join("\n"));
        impl.errors = {};
        impl.fireEvent("before_beacon", impl.vars);
        impl.beacon_url = impl.beacon_url_override || impl.beacon_url;
        BOOMR.debug(
          "Ready to send beacon: " + BOOMR.utils.objectToString(impl.vars)
        );
        if (!impl.beacon_url) {
          BOOMR.debug("No beacon URL, so skipping.");
          return !0;
        }
        for (k in impl.vars) {
          if (impl.vars.hasOwnProperty(k)) {
            varsSent[k] = impl.vars[k];
            varsToSend[k] = impl.vars[k];
          }
        }
        urlFirst = this.getVarsOfPriority(varsToSend, -1);
        urlLast = this.getVarsOfPriority(varsToSend, 1);
        params = urlFirst.concat(
          this.getVarsOfPriority(varsToSend, 0),
          urlLast
        );
        paramsJoined = params.join("&");
        url =
          impl.beacon_url +
          (impl.beacon_url.indexOf("?") > -1 ? "&" : "?") +
          paramsJoined;
        ("POST" === impl.beacon_type ||
          url.length > BOOMR.constants.MAX_GET_LENGTH) &&
          (useImg = !1);
        BOOMR.removeVar("qt");
        impl.fireEvent("onbeacon", varsSent);
        if (0 === params.length) {
          return this;
        }
        BOOMR.orig_XMLHttpRequest ||
          (BOOMR.window && BOOMR.window.XMLHttpRequest) ||
          (useImg = !0);
        if (useImg) {
          img = new Image();
          img.src = url;
          if (impl.secondary_beacons) {
            for (k = 0; k < impl.secondary_beacons.length; k++) {
              url = impl.secondary_beacons[k] + "?" + paramsJoined;
              img = new Image();
              img.src = url;
            }
          }
        } else {
          xhr = new (BOOMR.orig_XMLHttpRequest ||
            BOOMR.window.XMLHttpRequest)();
          xhr.open("POST", impl.beacon_url);
          xhr.setRequestHeader(
            "Content-type",
            "application/x-www-form-urlencoded"
          );
          if (void 0 !== impl.beacon_auth_token) {
            void 0 === impl.beacon_auth_key &&
              (impl.beacon_auth_key = "Authorization");
            xhr.setRequestHeader(impl.beacon_auth_key, impl.beacon_auth_token);
          }
          xhr.send(paramsJoined);
        }
        return !0;
      },
      getVarsOfPriority: function (vars, pri) {
        var name,
          url = [];
        if (0 !== pri) {
          for (name in impl.varPriority[pri]) {
            if (
              impl.varPriority[pri].hasOwnProperty(name) &&
              vars.hasOwnProperty(name)
            ) {
              url.push(this.getUriEncodedVar(name, vars[name]));
              delete vars[name];
            }
          }
        } else {
          for (name in vars) {
            vars.hasOwnProperty(name) &&
              url.push(this.getUriEncodedVar(name, vars[name]));
          }
        }
        return url;
      },
      getUriEncodedVar: function (name, value) {
        return (
          encodeURIComponent(name) +
          "=" +
          (void 0 === value || null === value ? "" : encodeURIComponent(value))
        );
      },
      getResourceTiming: function (url, sort) {
        var entries;
        try {
          if (
            BOOMR.getPerformance() &&
            "function" == typeof BOOMR.getPerformance().getEntriesByName
          ) {
            entries = BOOMR.getPerformance().getEntriesByName(url);
            if (entries && entries.length) {
              "function" == typeof sort && entries.sort(sort);
              return entries[entries.length - 1];
            }
          }
        } catch (ignore) {}
      },
    };
    delete BOOMR_start;
    if ("number" == typeof BOOMR_lstart) {
      boomr.t_lstart = BOOMR_lstart;
      delete BOOMR_lstart;
    } else {
      "number" == typeof BOOMR.window.BOOMR_lstart &&
        (boomr.t_lstart = BOOMR.window.BOOMR_lstart);
    }
    "number" == typeof BOOMR.window.BOOMR_onload &&
      (boomr.t_onload = BOOMR.window.BOOMR_onload);
    (function () {
      var make_logger;
      "object" == typeof console &&
        void 0 !== console.log &&
        (boomr.log = function (m, l, s) {});
      make_logger = function (l) {
        return function (m, s) {
          this.log(m, l, "boomerang" + (s ? "." + s : ""));
          return this;
        };
      };
      boomr.debug = make_logger("debug");
      boomr.info = make_logger("info");
      boomr.warn = make_logger("warn");
      boomr.error = make_logger("error");
    })();
    (function () {
      var ident;
      for (ident in boomr) {
        boomr.hasOwnProperty(ident) && (BOOMR[ident] = boomr[ident]);
      }
      BOOMR.xhr_excludes || (BOOMR.xhr_excludes = {});
    })();
    dispatchEvent("onBoomerangLoaded", { BOOMR: BOOMR }, !0);
  }
})(window);
(function (w) {
  var d, impl;
  if (!BOOMR.plugins.RT) {
    impl = {
      onloadfired: !1,
      unloadfired: !1,
      visiblefired: !1,
      initialized: !1,
      complete: !1,
      autorun: !0,
      timers: {},
      cookie: "RT",
      cookie_exp: 604800,
      strict_referrer: !0,
      navigationType: 0,
      navigationStart: void 0,
      responseStart: void 0,
      t_start: void 0,
      cached_t_start: void 0,
      cached_xhr_start: void 0,
      t_fb_approx: void 0,
      r: void 0,
      r2: void 0,
      basic_timers: { t_done: 1, t_resp: 1, t_page: 1 },
      addedVars: [],
      updateCookie: function (params, timer) {
        var t_end, t_start, subcookies, k;
        if (!this.cookie) {
          return !1;
        }
        subcookies =
          BOOMR.utils.getSubCookies(BOOMR.utils.getCookie(this.cookie)) || {};
        if ("object" == typeof params) {
          for (k in params) {
            if (params.hasOwnProperty(k)) {
              if (void 0 === params[k]) {
                subcookies.hasOwnProperty(k) && delete subcookies[k];
              } else {
                ("nu" !== k && "r" !== k) ||
                  (params[k] = BOOMR.utils.hashQueryString(params[k], !0));
                subcookies[k] = params[k];
              }
            }
          }
        }
        t_start = BOOMR.now();
        if (timer) {
          subcookies[timer] = t_start;
          impl.lastActionTime = t_start;
        }
        BOOMR.debug(
          "Setting cookie (timer=" +
            timer +
            ")\n" +
            BOOMR.utils.objectToString(subcookies),
          "rt"
        );
        if (!BOOMR.utils.setCookie(this.cookie, subcookies, this.cookie_exp)) {
          BOOMR.error("cannot set start cookie", "rt");
          return !1;
        }
        t_end = BOOMR.now();
        if (t_end - t_start > 50) {
          BOOMR.utils.removeCookie(this.cookie);
          BOOMR.error(
            "took more than 50ms to set cookie... aborting: " +
              t_start +
              " -> " +
              t_end,
            "rt"
          );
        }
        return !0;
      },
      initFromCookie: function () {
        var url, subcookies;
        subcookies = BOOMR.utils.getSubCookies(
          BOOMR.utils.getCookie(this.cookie)
        );
        if (subcookies) {
          subcookies.s = Math.max(
            +subcookies.ld || 0,
            Math.max(+subcookies.ul || 0, +subcookies.cl || 0)
          );
          BOOMR.debug(
            "Read from cookie " + BOOMR.utils.objectToString(subcookies),
            "rt"
          );
          if (subcookies.s && (subcookies.r || subcookies.nu)) {
            this.r = subcookies.r;
            url = BOOMR.utils.hashQueryString(d.URL, !0);
            BOOMR.debug(this.r + " =?= " + this.r2, "rt");
            BOOMR.debug(subcookies.s + " <? " + (+subcookies.cl + 15), "rt");
            BOOMR.debug(subcookies.nu + " =?= " + url, "rt");
            if (
              !this.strict_referrer ||
              (subcookies.nu &&
                subcookies.nu === url &&
                subcookies.s < +subcookies.cl + 15) ||
              (subcookies.s === +subcookies.ul && this.r === this.r2)
            ) {
              this.t_start = subcookies.s;
              +subcookies.hd > subcookies.s &&
                (this.t_fb_approx = parseInt(subcookies.hd, 10));
            } else {
              this.t_start = this.t_fb_approx = void 0;
            }
          }
          this.updateCookie({
            s: void 0,
            r: void 0,
            nu: void 0,
            ul: void 0,
            cl: void 0,
            hd: void 0,
            ld: void 0,
            rl: void 0,
          });
        }
      },
      getBoomerangTimings: function () {
        function trimTiming(time, st) {
          var timeMs = Math.round(time || 0),
            startTimeMs = Math.round(st || 0);
          timeMs = 0 === timeMs ? 0 : timeMs - startTimeMs;
          return timeMs || "";
        }
        var res, urls, url, startTime, data;
        if (BOOMR.t_start) {
          BOOMR.plugins.RT.startTimer("boomerang", BOOMR.t_start);
          BOOMR.plugins.RT.endTimer("boomerang", BOOMR.t_end);
          BOOMR.plugins.RT.endTimer("boomr_fb", BOOMR.t_start);
          if (BOOMR.t_lstart) {
            BOOMR.plugins.RT.endTimer("boomr_ld", BOOMR.t_lstart);
            BOOMR.plugins.RT.setTimer(
              "boomr_lat",
              BOOMR.t_start - BOOMR.t_lstart
            );
          }
        }
        try {
          if (
            window &&
            "performance" in window &&
            window.performance &&
            "function" == typeof window.performance.getEntriesByName
          ) {
            urls = { "rt.bmr": BOOMR.url };
            for (url in urls) {
              if (urls.hasOwnProperty(url) && urls[url]) {
                res = window.performance.getEntriesByName(urls[url]);
                if (!res || 0 === res.length || !res[0]) {
                  continue;
                }
                res = res[0];
                startTime = trimTiming(res.startTime, 0);
                data = [
                  startTime,
                  trimTiming(res.responseEnd, startTime),
                  trimTiming(res.responseStart, startTime),
                  trimTiming(res.requestStart, startTime),
                  trimTiming(res.connectEnd, startTime),
                  trimTiming(res.secureConnectionStart, startTime),
                  trimTiming(res.connectStart, startTime),
                  trimTiming(res.domainLookupEnd, startTime),
                  trimTiming(res.domainLookupStart, startTime),
                  trimTiming(res.redirectEnd, startTime),
                  trimTiming(res.redirectStart, startTime),
                ]
                  .join(",")
                  .replace(/,+$/, "");
                BOOMR.addVar(url, data);
                impl.addedVars.push(url);
              }
            }
          }
        } catch (e) {
          BOOMR.addError(e, "rt.getBoomerangTimings");
        }
      },
      checkPreRender: function () {
        if ("prerender" !== BOOMR.visibilityState()) {
          return !1;
        }
        BOOMR.plugins.RT.startTimer("t_load", this.navigationStart);
        BOOMR.plugins.RT.endTimer("t_load");
        BOOMR.plugins.RT.startTimer("t_prerender", this.navigationStart);
        BOOMR.plugins.RT.startTimer("t_postrender");
        return !0;
      },
      initFromNavTiming: function () {
        var ti, p, source;
        if (!this.navigationStart) {
          p = BOOMR.getPerformance();
          p && p.navigation && (this.navigationType = p.navigation.type);
          if (p && p.timing) {
            ti = p.timing;
          } else if (w.chrome && w.chrome.csi && w.chrome.csi().startE) {
            ti = { navigationStart: w.chrome.csi().startE };
            source = "csi";
          } else if (w.gtbExternal && w.gtbExternal.startE()) {
            ti = { navigationStart: w.gtbExternal.startE() };
            source = "gtb";
          }
          if (ti) {
            BOOMR.addVar("rt.start", source || "navigation");
            this.navigationStart =
              ti.navigationStart || ti.fetchStart || void 0;
            this.responseStart = ti.responseStart || void 0;
            navigator.userAgent.match(/Firefox\/[78]\./) &&
              (this.navigationStart =
                ti.unloadEventStart || ti.fetchStart || void 0);
          } else {
            BOOMR.warn("This browser doesn't support the WebTiming API", "rt");
          }
        }
      },
      validateLoadTimestamp: function (t_now, data, ename) {
        var p;
        if (data && data.timing && data.timing.loadEventEnd) {
          return data.timing.loadEventEnd;
        }
        if (
          !(
            "xhr" !== ename ||
            (data &&
              BOOMR.utils.inArray(
                data.initiator,
                BOOMR.constants.BEACON_TYPE_SPAS
              ))
          )
        ) {
          return t_now;
        }
        if (BOOMR.loadedLate) {
          p = BOOMR.getPerformance();
          if (!p || !p.timing) {
            return BOOMR.t_onload || BOOMR.t_lstart || BOOMR.t_start || t_now;
          }
          if (
            p.timing.loadEventStart &&
            p.timing.loadEventStart < BOOMR.t_end
          ) {
            return p.timing.loadEventStart;
          }
        }
        return t_now;
      },
      setPageLoadTimers: function (ename, t_done, data) {
        var t_resp_start, t_fetch_start, p, navSt;
        if ("xhr" !== ename) {
          impl.initFromCookie();
          impl.initFromNavTiming();
          if (impl.checkPreRender()) {
            return !1;
          }
        }
        if ("xhr" === ename) {
          if (data.timers) {
            for (var timerName in data.timers) {
              data.timers.hasOwnProperty(timerName) &&
                BOOMR.plugins.RT.setTimer(timerName, data.timers[timerName]);
            }
          } else if (data && data.timing) {
            t_resp_start = data.timing.responseEnd;
            t_fetch_start = data.timing.fetchStart;
            p = BOOMR.getPerformance();
            var entry = BOOMR.getResourceTiming(data.url);
            if (entry && p) {
              navSt = p.timing.navigationStart;
              t_resp_start = Math.round(navSt + entry.responseEnd);
              t_fetch_start = Math.round(navSt + entry.startTime);
            }
          }
        } else {
          impl.responseStart
            ? (t_resp_start = impl.responseStart)
            : impl.timers.hasOwnProperty("t_page")
            ? BOOMR.plugins.RT.endTimer("t_page")
            : impl.t_fb_approx && (t_resp_start = impl.t_fb_approx);
        }
        if (t_resp_start) {
          t_fetch_start
            ? BOOMR.plugins.RT.setTimer("t_resp", t_fetch_start, t_resp_start)
            : BOOMR.plugins.RT.endTimer("t_resp", t_resp_start);
          impl.timers.t_load
            ? BOOMR.plugins.RT.setTimer(
                "t_page",
                impl.timers.t_load.end - t_resp_start
              )
            : t_done < t_resp_start
            ? BOOMR.addVar("t_page.inv", 1)
            : BOOMR.plugins.RT.setTimer("t_page", t_done - t_resp_start);
        }
        if (impl.timers.hasOwnProperty("t_postrender")) {
          BOOMR.plugins.RT.endTimer("t_postrender");
          BOOMR.plugins.RT.endTimer("t_prerender");
        }
        return !0;
      },
      setSupportingTimestamps: function (t_start) {
        t_start && BOOMR.addVar("rt.tstart", t_start);
        "number" == typeof impl.t_start &&
          impl.t_start !== t_start &&
          BOOMR.addVar("rt.cstart", impl.t_start);
        BOOMR.addVar("rt.bstart", BOOMR.t_start);
        BOOMR.t_lstart && BOOMR.addVar("rt.blstart", BOOMR.t_lstart);
        BOOMR.addVar("rt.end", impl.timers.t_done.end);
      },
      determineTStart: function (ename, data) {
        var t_start;
        if ("xhr" === ename) {
          data && data.name && impl.timers[data.name]
            ? (t_start = impl.timers[data.name].start)
            : data &&
              data.timing &&
              data.timing.requestStart &&
              (t_start = data.timing.requestStart);
          void 0 === t_start &&
          data &&
          BOOMR.utils.inArray(data.initiator, BOOMR.constants.BEACON_TYPE_SPAS)
            ? BOOMR.addVar("rt.start", "none")
            : BOOMR.addVar("rt.start", "manual");
          impl.cached_xhr_start = t_start;
        } else {
          if (impl.navigationStart) {
            t_start = impl.navigationStart;
          } else if (impl.t_start && 2 !== impl.navigationType) {
            t_start = impl.t_start;
            BOOMR.addVar("rt.start", "cookie");
          } else if (impl.cached_t_start) {
            t_start = impl.cached_t_start;
          } else {
            BOOMR.addVar("rt.start", "none");
            t_start = void 0;
          }
          impl.cached_t_start = t_start;
        }
        BOOMR.debug("Got start time: " + t_start, "rt");
        return t_start;
      },
      page_ready: function () {
        this.onloadfired = !0;
      },
      check_visibility: function () {
        "visible" === BOOMR.visibilityState() && (impl.visiblefired = !0);
      },
      prerenderToVisible: function () {
        if (impl.onloadfired && impl.autorun) {
          BOOMR.debug(
            "Transitioned from prerender to " + BOOMR.visibilityState(),
            "rt"
          );
          BOOMR.addVar("vis.pre", "1");
          BOOMR.plugins.RT.done(null, "visible");
        }
      },
      page_unload: function (edata) {
        BOOMR.debug(
          "Unload called when unloadfired = " + this.unloadfired,
          "rt"
        );
        this.unloadfired || BOOMR.plugins.RT.done(edata, "unload");
        this.updateCookie(
          { r: d.URL },
          "beforeunload" === edata.type ? "ul" : "hd"
        );
        this.unloadfired = !0;
      },
      _iterable_click: function (name, element, etarget, value_cb) {
        var value;
        if (etarget) {
          BOOMR.debug(name + " called with " + etarget.nodeName, "rt");
          while (etarget && etarget.nodeName.toUpperCase() !== element) {
            etarget = etarget.parentNode;
          }
          if (etarget && etarget.nodeName.toUpperCase() === element) {
            BOOMR.debug("passing through", "rt");
            value = value_cb(etarget);
            this.updateCookie({ nu: value }, "cl");
            BOOMR.addVar("nu", BOOMR.utils.cleanupURL(value));
            impl.addedVars.push("nu");
          }
        }
      },
      onclick: function (etarget) {
        impl._iterable_click("Click", "A", etarget, function (t) {
          return t.href;
        });
      },
      onerror: function () {
        this.onloadfired && (impl.complete = !0);
      },
      onsubmit: function (etarget) {
        impl._iterable_click("Submit", "FORM", etarget, function (t) {
          var v = t.getAttribute("action") || d.URL || "";
          return v.match(/\?/) ? v : v + "?";
        });
      },
      domloaded: function () {
        BOOMR.plugins.RT.endTimer("t_domloaded");
      },
      clear: function () {
        BOOMR.removeVar("rt.start");
        if (impl.addedVars && impl.addedVars.length > 0) {
          BOOMR.removeVar(impl.addedVars);
          impl.addedVars = [];
        }
      },
    };
    BOOMR.plugins.RT = {
      init: function (config) {
        BOOMR.debug("init RT", "rt");
        w !== BOOMR.window && (w = BOOMR.window);
        if (w && w.document) {
          d = w.document;
          BOOMR.utils.pluginConfig(impl, config, "RT", [
            "cookie",
            "cookie_exp",
            "session_exp",
            "strict_referrer",
          ]);
          config &&
            void 0 !== config.autorun &&
            (impl.autorun = config.autorun);
          void 0 !== d &&
            (impl.r = impl.r2 = BOOMR.utils.hashQueryString(d.referrer, !0));
          impl.initFromCookie();
          if (impl.initialized) {
            return this;
          }
          impl.complete = !1;
          impl.timers = {};
          impl.check_visibility();
          BOOMR.subscribe("page_ready", impl.page_ready, null, impl);
          BOOMR.subscribe(
            "visibility_changed",
            impl.check_visibility,
            null,
            impl
          );
          BOOMR.subscribe(
            "prerender_to_visible",
            impl.prerenderToVisible,
            null,
            impl
          );
          BOOMR.subscribe("page_ready", this.done, "load", this);
          BOOMR.subscribe("xhr_load", this.done, "xhr", this);
          BOOMR.subscribe("dom_loaded", impl.domloaded, null, impl);
          BOOMR.subscribe("page_unload", impl.page_unload, null, impl);
          BOOMR.subscribe("click", impl.onclick, null, impl);
          BOOMR.subscribe("form_submit", impl.onsubmit, null, impl);
          BOOMR.subscribe(
            "before_beacon",
            this.addTimersToBeacon,
            "beacon",
            this
          );
          BOOMR.subscribe("onbeacon", impl.clear, null, impl);
          BOOMR.subscribe("onerror", impl.onerror, null, impl);
          BOOMR.getBeaconURL = function () {
            return impl.beacon_url;
          };
          impl.initialized = !0;
          return this;
        }
      },
      startTimer: function (timer_name, time_value) {
        if (timer_name) {
          "t_page" === timer_name && this.endTimer("t_resp", time_value);
          impl.timers[timer_name] = {
            start: "number" == typeof time_value ? time_value : BOOMR.now(),
          };
        }
        return this;
      },
      endTimer: function (timer_name, time_value) {
        if (timer_name) {
          impl.timers[timer_name] = impl.timers[timer_name] || {};
          void 0 === impl.timers[timer_name].end &&
            (impl.timers[timer_name].end =
              "number" == typeof time_value ? time_value : BOOMR.now());
        }
        return this;
      },
      setTimer: function (timer_name, time_delta_or_start, timer_end) {
        timer_name &&
          (impl.timers[timer_name] =
            void 0 !== timer_end
              ? {
                  start: time_delta_or_start,
                  end: timer_end,
                  delta: timer_end - time_delta_or_start,
                }
              : { delta: time_delta_or_start });
        return this;
      },
      addTimersToBeacon: function (vars, source) {
        var t_name,
          timer,
          t_other = [];
        for (t_name in impl.timers) {
          if (impl.timers.hasOwnProperty(t_name)) {
            timer = impl.timers[t_name];
            if ("number" != typeof timer.delta) {
              "number" != typeof timer.start &&
                (timer.start =
                  "xhr" === source
                    ? impl.cached_xhr_start
                    : impl.cached_t_start);
              timer.delta = timer.end - timer.start;
            }
            if (isNaN(timer.delta)) {
              continue;
            }
            if (impl.basic_timers.hasOwnProperty(t_name)) {
              BOOMR.addVar(t_name, timer.delta);
              impl.addedVars.push(t_name);
            } else {
              t_other.push(t_name + "|" + timer.delta);
            }
          }
        }
        if (t_other.length) {
          BOOMR.addVar("t_other", t_other.join(","));
          impl.addedVars.push("t_other");
        }
        if ("beacon" === source) {
          impl.timers = {};
          impl.complete = !1;
        }
      },
      done: function (edata, ename) {
        BOOMR.debug("Called done: " + ename, "rt");
        var t_start,
          t_done,
          t_now = BOOMR.now(),
          subresource = !1;
        impl.complete = !1;
        t_done = impl.validateLoadTimestamp(t_now, edata, ename);
        if (
          ("load" === ename || "visible" === ename || "xhr" === ename) &&
          !impl.setPageLoadTimers(ename, t_done, edata)
        ) {
          return this;
        }
        ("load" === ename ||
          "visible" === ename ||
          ("xhr" === ename &&
            edata &&
            BOOMR.utils.inArray(
              edata.initiator,
              BOOMR.constants.BEACON_TYPE_SPAS
            ))) &&
          impl.getBoomerangTimings();
        t_start = impl.determineTStart(ename, edata);
        this.endTimer("t_done", t_done);
        edata &&
          "xhr" === edata.initiator &&
          this.setTimer(
            "t_done",
            edata.timing.requestStart,
            edata.timing.loadEventEnd
          );
        BOOMR.removeVar(
          "t_done",
          "t_page",
          "t_resp",
          "t_postrender",
          "t_prerender",
          "t_load",
          "t_other",
          "r",
          "r2",
          "rt.tstart",
          "rt.cstart",
          "rt.bstart",
          "rt.end",
          "rt.subres",
          "rt.abld",
          "http.errno",
          "http.method",
          "xhr.sync"
        );
        impl.setSupportingTimestamps(t_start);
        this.addTimersToBeacon(null, ename);
        BOOMR.addVar("r", BOOMR.utils.cleanupURL(impl.r));
        impl.r2 !== impl.r &&
          BOOMR.addVar("r2", BOOMR.utils.cleanupURL(impl.r2));
        "xhr" === ename && edata && edata && edata.data && (edata = edata.data);
        if ("xhr" === ename && edata) {
          subresource = edata.subresource;
          if (edata.url) {
            BOOMR.addVar(
              "u",
              BOOMR.utils.cleanupURL(edata.url.replace(/#.*/, ""))
            );
            impl.addedVars.push("u");
          }
          edata.status &&
            (edata.status < -1 || edata.status >= 400) &&
            BOOMR.addVar("http.errno", edata.status);
          edata.method &&
            "GET" !== edata.method &&
            BOOMR.addVar("http.method", edata.method);
          edata.headers && BOOMR.addVar("http.hdr", edata.headers);
          edata.synchronous && BOOMR.addVar("xhr.sync", 1);
          edata.initiator && BOOMR.addVar("http.initiator", edata.initiator);
          impl.addedVars.push(
            "http.errno",
            "http.method",
            "http.hdr",
            "xhr.sync",
            "http.initiator"
          );
        }
        if (subresource && "passive" !== subresource) {
          BOOMR.addVar("rt.subres", 1);
          impl.addedVars.push("rt.subres");
        }
        impl.updateCookie();
        if ("unload" === ename) {
          BOOMR.addVar("rt.quit", "");
          impl.onloadfired || BOOMR.addVar("rt.abld", "");
          impl.visiblefired || BOOMR.addVar("rt.ntvu", "");
        }
        impl.complete = !0;
        BOOMR.sendBeacon();
        return this;
      },
      is_complete: function () {
        return impl.complete;
      },
      updateCookie: function () {
        impl.updateCookie();
      },
      navigationStart: function () {
        impl.navigationStart || impl.initFromNavTiming();
        return impl.navigationStart;
      },
    };
  }
})(window);
(function () {
  if (!BOOMR.plugins.NavigationTiming) {
    var impl = {
      complete: !1,
      sendBeacon: function () {
        this.complete = !0;
        BOOMR.sendBeacon();
      },
      xhr_done: function (edata) {
        var p;
        if (edata && "spa_hard" === edata.initiator) {
          impl.done(edata);
        } else if (edata && "spa" === edata.initiator) {
          impl.sendBeacon();
        } else {
          var res,
            k,
            data = (BOOMR.window, {});
          if (edata) {
            edata.data && (edata = edata.data);
            p = BOOMR.getPerformance();
            if (edata.url && p) {
              res = BOOMR.getResourceTiming(edata.url, function (a, b) {
                return a.responseEnd - b.responseEnd;
              });
              if (res) {
                data = {
                  nt_red_st: res.redirectStart,
                  nt_red_end: res.redirectEnd,
                  nt_fet_st: res.fetchStart,
                  nt_dns_st: res.domainLookupStart,
                  nt_dns_end: res.domainLookupEnd,
                  nt_con_st: res.connectStart,
                  nt_con_end: res.connectEnd,
                  nt_req_st: res.requestStart,
                  nt_res_st: res.responseStart,
                  nt_res_end: res.responseEnd,
                };
                res.secureConnectionStart &&
                  (data.nt_ssl_st = res.secureConnectionStart);
                for (k in data) {
                  if (data.hasOwnProperty(k) && data[k]) {
                    data[k] += p.timing.navigationStart;
                    data[k] = Math.round(data[k]);
                  }
                }
              }
            }
            if (edata.timing) {
              res = edata.timing;
              data.nt_req_st || (data.nt_req_st = res.requestStart);
              data.nt_res_st || (data.nt_res_st = res.responseStart);
              data.nt_res_end || (data.nt_res_end = res.responseEnd);
              data.nt_domint = res.domInteractive;
              data.nt_domcomp = res.domComplete;
              data.nt_load_st = res.loadEventEnd;
              data.nt_load_end = res.loadEventEnd;
            }
            for (k in data) {
              data.hasOwnProperty(k) && !data[k] && delete data[k];
            }
            BOOMR.addVar(data);
            try {
              impl.addedVars.push.apply(impl.addedVars, Object.keys(data));
            } catch (ignore) {}
            impl.sendBeacon();
          }
        }
      },
      done: function () {
        var p,
          pn,
          pt,
          data,
          w = BOOMR.window;
        if (this.complete) {
          return this;
        }
        impl.addedVars = [];
        p = BOOMR.getPerformance();
        if (p && p.timing && p.navigation) {
          BOOMR.info("This user agent supports NavigationTiming.", "nt");
          pn = p.navigation;
          pt = p.timing;
          data = {
            nt_red_cnt: pn.redirectCount,
            nt_nav_type: pn.type,
            nt_nav_st: pt.navigationStart,
            nt_red_st: pt.redirectStart,
            nt_red_end: pt.redirectEnd,
            nt_fet_st: pt.fetchStart,
            nt_dns_st: pt.domainLookupStart,
            nt_dns_end: pt.domainLookupEnd,
            nt_con_st: pt.connectStart,
            nt_con_end: pt.connectEnd,
            nt_req_st: pt.requestStart,
            nt_res_st: pt.responseStart,
            nt_res_end: pt.responseEnd,
            nt_domloading: pt.domLoading,
            nt_domint: pt.domInteractive,
            nt_domcontloaded_st: pt.domContentLoadedEventStart,
            nt_domcontloaded_end: pt.domContentLoadedEventEnd,
            nt_domcomp: pt.domComplete,
            nt_load_st: pt.loadEventStart,
            nt_load_end: pt.loadEventEnd,
            nt_unload_st: pt.unloadEventStart,
            nt_unload_end: pt.unloadEventEnd,
          };
          pt.secureConnectionStart &&
            (data.nt_ssl_st = pt.secureConnectionStart);
          pt.msFirstPaint && (data.nt_first_paint = pt.msFirstPaint);
          BOOMR.addVar(data);
          try {
            impl.addedVars.push.apply(impl.addedVars, Object.keys(data));
          } catch (ignore) {}
        }
        if (w.chrome && w.chrome.loadTimes) {
          pt = w.chrome.loadTimes();
          if (pt) {
            data = {
              nt_spdy: pt.wasFetchedViaSpdy ? 1 : 0,
              nt_cinf: pt.connectionInfo,
              nt_first_paint: pt.firstPaintTime,
            };
            BOOMR.addVar(data);
            try {
              impl.addedVars.push.apply(impl.addedVars, Object.keys(data));
            } catch (ignore) {}
          }
        }
        impl.sendBeacon();
      },
      clear: function () {
        if (impl.addedVars && impl.addedVars.length > 0) {
          BOOMR.removeVar(impl.addedVars);
          impl.addedVars = [];
        }
        this.complete = !1;
      },
      prerenderToVisible: function () {
        this.complete = !1;
        this.done();
      },
    };
    BOOMR.plugins.NavigationTiming = {
      init: function () {
        if (!impl.initialized) {
          BOOMR.subscribe("page_ready", impl.done, null, impl);
          BOOMR.subscribe(
            "prerender_to_visible",
            impl.prerenderToVisible,
            null,
            impl
          );
          BOOMR.subscribe("xhr_load", impl.xhr_done, null, impl);
          BOOMR.subscribe("before_unload", impl.done, null, impl);
          BOOMR.subscribe("onbeacon", impl.clear, null, impl);
          impl.initialized = !0;
        }
        return this;
      },
      is_complete: function () {
        return !0;
      },
    };
  }
})();
(function () {
  function convertToTrie(entries) {
    var url,
      urlFixed,
      i,
      value,
      letters,
      letter,
      cur,
      node,
      trie = {};
    for (url in entries) {
      urlFixed = url;
      for (i = 0; i < impl.xssBreakWords.length; i++) {
        urlFixed = urlFixed.replace(
          impl.xssBreakWords[i],
          "$1" + XSS_BREAK_DELIM + "$2"
        );
      }
      if (entries.hasOwnProperty(url)) {
        value = entries[url];
        letters = urlFixed.split("");
        cur = trie;
        for (i = 0; i < letters.length; i++) {
          letter = letters[i];
          node = cur[letter];
          void 0 === node
            ? (cur = cur[letter] = i === letters.length - 1 ? value : {})
            : "string" == typeof node
            ? (cur = cur[letter] = { "|": node })
            : i === letters.length - 1
            ? (cur[letter]["|"] = value)
            : (cur = cur[letter]);
        }
      }
    }
    return trie;
  }
  function optimizeTrie(cur, top) {
    var node,
      ret,
      topNode,
      num = 0;
    var keys = [];
    for (node in cur) {
      cur.hasOwnProperty(node) && keys.push(node);
    }
    for (var i = 0; i < keys.length; i++) {
      node = keys[i];
      if ("object" == typeof cur[node]) {
        ret = optimizeTrie(cur[node], !1);
        if (ret) {
          delete cur[node];
          if (node === XSS_BREAK_DELIM) {
            node = ret.name;
            num++;
          } else {
            node += ret.name;
          }
          cur[node] = ret.value;
        }
      }
      num++;
    }
    if (1 === num) {
      if (top) {
        topNode = {};
        topNode[node] = cur[node];
        return topNode;
      }
      return { name: node, value: cur[node] };
    }
    return !!top && cur;
  }
  function trimTiming(time, startTime) {
    "number" != typeof time && (time = 0);
    "number" != typeof startTime && (startTime = 0);
    var timeMs = Math.round(time || 0),
      startTimeMs = Math.round(startTime || 0);
    return 0 === timeMs ? 0 : timeMs - startTimeMs;
  }
  function getNavStartTime(frame) {
    var navStart = 0;
    try {
      frame.location && frame.location.href;
      "performance" in frame &&
        frame.performance &&
        frame.performance.timing &&
        frame.performance.timing.navigationStart &&
        (navStart = frame.performance.timing.navigationStart);
    } catch (e) {}
    return navStart;
  }
  function findPerformanceEntriesForFrame(frame, isTopWindow, offset, depth) {
    var i,
      navEntries,
      navStart,
      frameNavStart,
      frameOffset,
      navEntry,
      t,
      entries = [];
    void 0 === isTopWindow && (isTopWindow = !0);
    void 0 === offset && (offset = 0);
    void 0 === depth && (depth = 0);
    if (depth > 10) {
      return entries;
    }
    try {
      navStart = getNavStartTime(frame);
      if (frame.frames) {
        for (i = 0; i < frame.frames.length; i++) {
          frameNavStart = getNavStartTime(frame.frames[i]);
          frameOffset = 0;
          frameNavStart > navStart &&
            (frameOffset = offset + (frameNavStart - navStart));
          entries = entries.concat(
            findPerformanceEntriesForFrame(
              frame.frames[i],
              !1,
              frameOffset,
              depth + 1
            )
          );
        }
      }
      try {
        frame.location && frame.location.href;
        if (
          !(
            "performance" in frame &&
            frame.performance &&
            "function" == typeof frame.performance.getEntriesByType
          )
        ) {
          return entries;
        }
      } catch (e) {
        return entries;
      }
      if (isTopWindow) {
        navEntries = frame.performance.getEntriesByType("navigation");
        if (navEntries && 1 === navEntries.length) {
          navEntry = navEntries[0];
          entries.push({
            name: frame.location.href,
            startTime: 0,
            initiatorType: "html",
            redirectStart: navEntry.redirectStart,
            redirectEnd: navEntry.redirectEnd,
            fetchStart: navEntry.fetchStart,
            domainLookupStart: navEntry.domainLookupStart,
            domainLookupEnd: navEntry.domainLookupEnd,
            connectStart: navEntry.connectStart,
            secureConnectionStart: navEntry.secureConnectionStart,
            connectEnd: navEntry.connectEnd,
            requestStart: navEntry.requestStart,
            responseStart: navEntry.responseStart,
            responseEnd: navEntry.responseEnd,
          });
        } else if (frame.performance.timing) {
          t = frame.performance.timing;
          0 !== t.navigationStart &&
            t.responseEnd <= t.navigationStart + 36e5 &&
            entries.push({
              name: frame.location.href,
              startTime: 0,
              initiatorType: "html",
              redirectStart: t.redirectStart
                ? t.redirectStart - t.navigationStart
                : 0,
              redirectEnd: t.redirectEnd
                ? t.redirectEnd - t.navigationStart
                : 0,
              fetchStart: t.fetchStart ? t.fetchStart - t.navigationStart : 0,
              domainLookupStart: t.domainLookupStart
                ? t.domainLookupStart - t.navigationStart
                : 0,
              domainLookupEnd: t.domainLookupEnd
                ? t.domainLookupEnd - t.navigationStart
                : 0,
              connectStart: t.connectStart
                ? t.connectStart - t.navigationStart
                : 0,
              secureConnectionStart: t.secureConnectionStart
                ? t.secureConnectionStart - t.navigationStart
                : 0,
              connectEnd: t.connectEnd ? t.connectEnd - t.navigationStart : 0,
              requestStart: t.requestStart
                ? t.requestStart - t.navigationStart
                : 0,
              responseStart: t.responseStart
                ? t.responseStart - t.navigationStart
                : 0,
              responseEnd: t.responseEnd
                ? t.responseEnd - t.navigationStart
                : 0,
            });
        }
      }
      var frameEntries = frame.performance.getEntriesByType("resource"),
        frameFixedEntries = [];
      for (i = 0; frameEntries && i < frameEntries.length; i++) {
        t = frameEntries[i];
        frameFixedEntries.push({
          name: t.name,
          initiatorType: t.initiatorType,
          startTime: t.startTime + offset,
          redirectStart: t.redirectStart ? t.redirectStart + offset : 0,
          redirectEnd: t.redirectEnd ? t.redirectEnd + offset : 0,
          fetchStart: t.fetchStart ? t.fetchStart + offset : 0,
          domainLookupStart: t.domainLookupStart
            ? t.domainLookupStart + offset
            : 0,
          domainLookupEnd: t.domainLookupEnd ? t.domainLookupEnd + offset : 0,
          connectStart: t.connectStart ? t.connectStart + offset : 0,
          secureConnectionStart: t.secureConnectionStart
            ? t.secureConnectionStart + offset
            : 0,
          connectEnd: t.connectEnd ? t.connectEnd + offset : 0,
          requestStart: t.requestStart ? t.requestStart + offset : 0,
          responseStart: t.responseStart ? t.responseStart + offset : 0,
          responseEnd: t.responseEnd ? t.responseEnd + offset : 0,
        });
      }
      entries = entries.concat(frameFixedEntries);
    } catch (e) {
      return entries;
    }
    return entries;
  }
  function toBase36(n) {
    return "number" == typeof n && 0 !== n
      ? n.toString(36)
      : "string" == typeof n
      ? n
      : "";
  }
  function getVisibleEntries(win) {
    var x,
      y,
      els = ["IMG", "IFRAME"],
      entries = {},
      doc = win.document;
    x =
      void 0 !== win.pageXOffset
        ? win.pageXOffset
        : (doc.documentElement || doc.body.parentNode || doc.body).scrollLeft;
    y =
      void 0 !== win.pageYOffset
        ? win.pageYOffset
        : (doc.documentElement || doc.body.parentNode || doc.body).scrollTop;
    els.forEach(function (elname) {
      var el,
        i,
        rect,
        elements = doc.getElementsByTagName(elname);
      for (i = 0; i < elements.length; i++) {
        el = elements[i];
        if (el && el.src && !entries[el.src]) {
          rect = el.getBoundingClientRect();
          (rect.height || el.offsetHeight) &&
            (rect.width || el.offsetWidth) &&
            (entries[el.src] = [
              el.offsetHeight,
              el.offsetWidth,
              Math.round(rect.top + y),
              Math.round(rect.left + x),
            ]);
        }
      }
    });
    return entries;
  }
  function getFilteredResourceTiming(from, to, initiatorTypes) {
    var i,
      e,
      entries = findPerformanceEntriesForFrame(BOOMR.window, !0, 0, 0),
      navStart = getNavStartTime(BOOMR.window);
    if (!entries || !entries.length) {
      return [];
    }
    var filteredEntries = [];
    for (i = 0; i < entries.length; i++) {
      e = entries[i];
      if (
        0 !== e.name.indexOf("about:") &&
        0 !== e.name.indexOf("javascript:") &&
        !(
          e.name.indexOf(BOOMR.url) > -1 ||
          e.name.indexOf(BOOMR.config_url) > -1 ||
          ("function" == typeof BOOMR.getBeaconURL &&
            BOOMR.getBeaconURL() &&
            e.name.indexOf(BOOMR.getBeaconURL()) > -1) ||
          (from && navStart + e.startTime < from)
        )
      ) {
        if (to && navStart + e.startTime > to) {
          break;
        }
        (void 0 === initiatorTypes ||
          "*" === initiatorTypes ||
          !initiatorTypes.length ||
          (e.initiatorType &&
            BOOMR.utils.inArray(e.initiatorType, initiatorTypes))) &&
          filteredEntries.push(e);
      }
    }
    return filteredEntries;
  }
  function compressSize(resource) {
    var sTrans, sEnc, sDec, sizes;
    if (
      resource.encodedBodySize ||
      resource.decodedBodySize ||
      resource.transferSize
    ) {
      sTrans = resource.transferSize;
      sEnc = resource.encodedBodySize;
      sDec = resource.decodedBodySize;
      sizes = [sEnc, sTrans ? sTrans - sEnc : "_", sDec ? sDec - sEnc : 0];
      return sizes.map(toBase36).join(",").replace(/,+$/, "");
    }
    return "";
  }
  function decompressSize(compressed, resource) {
    var split, i;
    void 0 === resource && (resource = {});
    split = compressed.split(",");
    for (i = 0; i < split.length; i++) {
      if ("_" === split[i]) {
        split[i] = 0;
      } else {
        "" === split[i] && (split[i] = 0);
        split[i] = parseInt(split[i], 36);
        i > 0 && (split[i] += split[0]);
      }
    }
    1 === split.length && split.push(split[0]);
    2 === split.length && split.push(split[0]);
    resource.encodedBodySize = split[0];
    resource.transferSize = split[1];
    resource.decodedBodySize = split[2];
    return resource;
  }
  function trimUrl(url, urlsToTrim) {
    var i, urlIdx, trim;
    if (url && urlsToTrim) {
      for (i = 0; i < urlsToTrim.length; i++) {
        trim = urlsToTrim[i];
        if ("string" == typeof trim) {
          urlIdx = url.indexOf(trim);
          if (-1 !== urlIdx) {
            url = url.substr(0, urlIdx + trim.length) + "...";
            break;
          }
        } else {
          trim instanceof RegExp &&
            trim.test(url) &&
            (url = url.replace(trim, "$1") + "...");
        }
      }
    }
    return BOOMR.utils.cleanupURL(url, impl.urlLimit);
  }
  function getCompressedResourceTiming(from, to) {
    var i,
      e,
      initiatorType,
      url,
      data,
      entries = getFilteredResourceTiming(from, to),
      results = {},
      visibleEntries = {};
    if (!entries || !entries.length) {
      return {};
    }
    visibleEntries = getVisibleEntries(BOOMR.window);
    for (i = 0; i < entries.length; i++) {
      e = entries[i];
      initiatorType = INITIATOR_TYPES[e.initiatorType];
      void 0 === initiatorType && (initiatorType = 0);
      data =
        initiatorType +
        [
          trimTiming(e.startTime, 0),
          trimTiming(e.responseEnd, e.startTime),
          trimTiming(e.responseStart, e.startTime),
          trimTiming(e.requestStart, e.startTime),
          trimTiming(e.connectEnd, e.startTime),
          trimTiming(e.secureConnectionStart, e.startTime),
          trimTiming(e.connectStart, e.startTime),
          trimTiming(e.domainLookupEnd, e.startTime),
          trimTiming(e.domainLookupStart, e.startTime),
          trimTiming(e.redirectEnd, e.startTime),
          trimTiming(e.redirectStart, e.startTime),
        ]
          .map(toBase36)
          .join(",")
          .replace(/,+$/, "");
      var compSize = compressSize(e);
      "" !== compSize &&
        (data += SPECIAL_DATA_PREFIX + SPECIAL_DATA_SIZE_TYPE + compSize);
      url = trimUrl(e.name, impl.trimUrls);
      void 0 !== results[url]
        ? (results[url] += "|" + data)
        : void 0 !== visibleEntries[url]
        ? (results[url] =
            SPECIAL_DATA_PREFIX +
            SPECIAL_DATA_DIMENSION_TYPE +
            visibleEntries[url].map(toBase36).join(",").replace(/,+$/, "") +
            "|" +
            data)
        : (results[url] = data);
    }
    return optimizeTrie(convertToTrie(results), !0);
  }
  function reduceFetchStarts(resources) {
    var times = [];
    if (!resources || !resources.length) {
      return times;
    }
    for (var i = 0; i < resources.length; i++) {
      var res = resources[i];
      (i !== resources.length - 1 &&
        res.fetchStart === resources[i + 1].fetchStart) ||
        times.push({
          fetchStart: res.fetchStart,
          responseEnd: res.responseStart || res.responseEnd,
        });
    }
    return times;
  }
  function calculateResourceTimingUnion(resources) {
    var i;
    if (!resources || !resources.length) {
      return 0;
    }
    resources.sort(function (a, b) {
      return a.fetchStart !== b.fetchStart
        ? a.fetchStart - b.fetchStart
        : (a.responseStart || a.responseEnd) -
            (b.responseStart || b.responseEnd);
    });
    var times = reduceFetchStarts(resources);
    var times2 = [];
    var furthestEnd = 0;
    for (i = 0; i < times.length; i++) {
      var res = times[i];
      res.fetchStart < furthestEnd && (res.fetchStart = furthestEnd);
      if (res.fetchStart < res.responseEnd) {
        times2.push(res);
        furthestEnd = res.responseEnd;
      }
    }
    var times3 = reduceFetchStarts(times2);
    var totalTime = 0;
    for (i = 0; i < times3.length; i++) {
      totalTime += times3[i].responseEnd - times3[i].fetchStart;
    }
    return totalTime;
  }
  var impl;
  if (!BOOMR.plugins.ResourceTiming) {
    var INITIATOR_TYPES = {
      other: 0,
      img: 1,
      link: 2,
      script: 3,
      css: 4,
      xmlhttprequest: 5,
      html: 6,
    };
    var DEFAULT_XSS_BREAK_WORDS = [/(h)(ref)/gi, /(s)(rc)/gi, /(a)(ction)/gi];
    var XSS_BREAK_DELIM = "\n";
    var SPECIAL_DATA_PREFIX = "*";
    var SPECIAL_DATA_DIMENSION_TYPE = "0";
    var SPECIAL_DATA_SIZE_TYPE = "1";
    impl = {
      complete: !1,
      sentNavBeacon: !1,
      initialized: !1,
      supported: !1,
      xhr_load: function () {
        if (!this.complete) {
          this.complete = !0;
          BOOMR.sendBeacon();
        }
      },
      xssBreakWords: DEFAULT_XSS_BREAK_WORDS,
      urlLimit: 500,
      clearOnBeacon: !1,
      trimUrls: [],
      done: function () {
        var r;
        if (!this.sentNavBeacon && "undefined" != typeof JSON) {
          BOOMR.removeVar("restiming");
          r = getCompressedResourceTiming();
          if (r) {
            BOOMR.info("Client supports Resource Timing API", "restiming");
            BOOMR.addVar({ restiming: JSON.stringify(r) });
          }
          this.complete = !0;
          this.sentNavBeacon = !0;
          BOOMR.sendBeacon();
        }
      },
      onBeacon: function (vars) {
        var p = BOOMR.getPerformance();
        vars.hasOwnProperty("restiming") && BOOMR.removeVar("restiming");
        if (impl.clearOnBeacon && p) {
          var clearResourceTimings =
            p.clearResourceTimings || p.webkitClearResourceTimings;
          clearResourceTimings &&
            "function" == typeof clearResourceTimings &&
            clearResourceTimings.call(p);
        }
      },
      prerenderToVisible: function () {
        this.sentNavBeacon = !1;
        this.done();
      },
    };
    BOOMR.plugins.ResourceTiming = {
      init: function (config) {
        var p = BOOMR.getPerformance();
        BOOMR.utils.pluginConfig(impl, config, "ResourceTiming", [
          "xssBreakWords",
          "clearOnBeacon",
          "urlLimit",
          "trimUrls",
        ]);
        if (impl.initialized) {
          return this;
        }
        if (p && "function" == typeof p.getEntriesByType) {
          BOOMR.subscribe("page_ready", impl.done, null, impl);
          BOOMR.subscribe(
            "prerender_to_visible",
            impl.prerenderToVisible,
            null,
            impl
          );
          BOOMR.subscribe("xhr_load", impl.xhr_load, null, impl);
          BOOMR.subscribe("onbeacon", impl.onBeacon, null, impl);
          BOOMR.subscribe("before_unload", impl.done, null, impl);
          impl.supported = !0;
        } else {
          impl.complete = !0;
        }
        impl.initialized = !0;
        return this;
      },
      is_complete: function () {
        return !0;
      },
      is_supported: function () {
        return impl.initialized && impl.supported;
      },
      getCompressedResourceTiming: getCompressedResourceTiming,
      getFilteredResourceTiming: getFilteredResourceTiming,
      calculateResourceTimingUnion: calculateResourceTimingUnion,
      trimTiming: trimTiming,
      convertToTrie: convertToTrie,
      optimizeTrie: optimizeTrie,
      findPerformanceEntriesForFrame: findPerformanceEntriesForFrame,
      toBase36: toBase36,
      getVisibleEntries: getVisibleEntries,
      reduceFetchStarts: reduceFetchStarts,
      compressSize: compressSize,
      decompressSize: decompressSize,
      trimUrl: trimUrl,
    };
  }
})();
(function () {
  var connection;
  "object" == typeof navigator &&
    (connection =
      navigator.connection ||
      navigator.mozConnection ||
      navigator.webkitConnection ||
      navigator.msConnection);
  if (connection) {
    BOOMR.addVar("mob.ct", connection.type);
    BOOMR.addVar("mob.bw", connection.bandwidth);
    BOOMR.addVar("mob.mt", connection.metered);
  }
})();
BOOMR.t_end = new Date().getTime();
BOOMR.init({
  beacon_url: "MonitoringService.asmx/Beacon",
  beacon_type: "POST",
  log: null,
  RT: { cookie: "lucid_boomr_rt", cookie_exp: 30 },
});
var BoomrUtils = {
  addTimer: function addTimer(elmId, timerName) {
    var elm = document.getElementById(elmId);
    if (elm) {
      BOOMR.plugins.RT.startTimer(timerName);
      elm.addEventListener(
        "load",
        function () {
          BOOMR.plugins.RT.endTimer(timerName);
        },
        { once: !0 }
      );
    }
  },
};
